<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Git</title>
    <link rel="icon" type="image/png" href="git.png" />
    <style type="text/css">
        h1{
            text-align: center;
        }
        h3{
            text-align: center;
        }
        p{
            text-align: center;
        }
        table{
            border-collapse: collapse;
            margin: auto;
        }
        table,tr,td{
            border: 1px solid black;
            padding: 25px;
            text-align: center;
            background-color: lightgray;
        }
        div{
            margin: auto;
            width: 50%;
            border: 3px solid brown;
            padding: 10px;
        }
    </style>
</head>
<body>
    
    <h1><img src="git.png" width="2%">Git</h1>
<p> Es un software de control de versiones diseñado por <em>Linus Torvalds</em>, pensando en la eficiencia 
y la confiabilidad del mantenimiento de versiones de aplicaciones cuando éstas tienen un gran número de archivos de código fuente.
Su propósito es llevar registro de los cambios en archivos de computadora y coordinar el trabajo que varias personas realizan sobre archivos compartidos.
<br/>
Al principio, <strong>Git</strong> se pensó como un motor de bajo nivel sobre el cual otros pudieran escribir la interfaz de usuario o front end 
como Cogito o StGIT.Hay algunos proyectos de mucha relevancia que ya usan Git, en particular, el grupo de programación del núcleo Linux.
<br/>
El mantenimiento del software Git está actualmente (2009) supervisado por Junio Hamano, quien recibe contribuciones al código de alrededor de 280 programadores.
En cuanto a derechos de autor Git es un software libre distribuible bajo los términos de la versión  de la Licencia Pública General de GNU.</p>

<h3>Características</h3>
<p>El diseño de Git se basó en <em>BitKeeper</em> y en <em>Monotone</em>. ​ Originalmente fue diseñado como un motor de sistema de control de versiones de bajo nivel 
sobre el cual otros podrían codificar interfaces frontales, tales como Cogito o StGIT. Desde ese entonces hasta ahora el núcleo del proyecto Git se ha vuelto 
un sistema de control de versiones completo, utilizable en forma directa.​
<br/>
Linus Torvalds buscaba un sistema distribuido que pudiera usar en forma semejante a BitKeeper, pero ninguno de los sistemas bajo software libre disponibles 
cumplía con sus requerimientos, especialmente en cuanto a desempeño. El diseño de Git mantiene una enorme cantidad de código distribuida y gestionada por mucha gente,
que incide en numerosos detalles de rendimiento, y de la necesidad de rapidez en una primera implementación.
</p>
<h3>Entre las características más relevantes se encuentran:</h3>
<ul>
    <li class="eleme001"><strong>Fuerte apoyo al desarrollo no lineal</strong>, por ende rapidez en la gestión de ramas y mezclado de diferentes versiones. </li>
    <li class="eleme002"><strong>Herramientas específicas</strong> para navegar y visualizar un historial de desarrollo no lineal. </li>
    <li class="eleme003"><strong>Gestión distribuida.</strong>  le da a cada programador una copia local del historial del desarrollo entero, y los cambios se 
        propagan entre los repositorios locales.</li>
    <li class="eleme004"><strong>Emular servidores CVS</strong></li>
    <li class="eleme005"><strong>Gestión eficiente de proyectos grandes</strong>, dada la rapidez de gestión de diferencias entre archivos, entre otras mejoras de optimización de velocidad de ejecución.
            Todas las versiones previas a un cambio determinado, implican la notificación de un cambio posterior en cualquiera de ellas a ese cambio 
            (denominado autenticación criptográfica de historial). </li>
     <li class="eleme006"><strong>Realmacenamiento periódico en paquetes (ficheros)</strong>. Esto es relativamente eficiente para escritura de cambios y relativamente ineficiente 
            para lectura si el reempaquetado (con base en diferencias) no ocurre cada cierto tiempo.</li>
</ul>

<table>
    <caption>Órdenes básicas</caption>
    <tr>
            <td ><strong>Orden</strong></td>
            <td><strong>Utilidad</strong></td>
        </tr>
        <tr>
            <td>git fetch:</td>
            <td>Descarga los cambios realizados en el repositorio remoto.</td>
        </tr>
        <tr>
            <td >git merge &#60;nombre_rama&#62;:</td>
            <td >Impacta en la rama en la que te encuentras parado, los cambios realizados en la rama “nombre_rama”.</td>
        </tr>
        <tr>
            <td>git pull:</td>
            <td>Unifica los comandos fetch y merge en un único comando.</td>
        </tr>
        <tr>
             <td>git commit -m "&#60;mensaje&#62;":</td>
             <td>Confirma los cambios realizados. El “mensaje” generalmente se usa para asociar al commit una breve descripción de los cambios realizados.</td>
         </tr>   
        <tr>
            <td>git push origin &#60;nombre_rama&#62;:</td>
            <td>Sube la rama “nombre_rama” al servidor remoto.</td>
        </tr>   
        <tr>
            <td>git status:</td>
            <td>Muestra el estado actual de la rama, como los cambios que hay sin commitear.</td>
        </tr>    
        <tr>
            <td>git add &#60;nombre_archivo&#62;:</td>
            <td>Comienza a trackear el archivo “nombre_archivo”.</td>
        </tr>    
        <tr>
            <td>git checkout -b &#60;nombre_rama_nueva&#62;:</td>
            <td>Crea una rama a partir de la que te encuentres parado con el nombre “nombre_rama_nueva”, y luego salta sobre la rama nueva, por lo que quedas parado en esta última.</td>
        </tr>   
        <tr>
            <td>git checkout -t origin/&#60;nombre_rama&#62;:</td>
            <td>Si existe una rama remota de nombre “nombre_rama”, al ejecutar este comando se crea una rama local con el nombre “nombre_rama” para hacer un seguimiento de la rama remota con el mismo nombre.</td>
        </tr>   
        <tr>
            <td>git branch:</td>
            <td>Lista todas las ramas locales.</td>
        </tr>   
        <tr>
            <td>git branch -d &#60;nombre_rama&#62;:</td>
            <td>Elimina la rama local con el nombre “nombre_rama”.</td>
        </tr>
        <tr>
            <td>git push origin &#60;nombre_rama&#62;:</td>
            <td>Commitea los cambios desde el branch local origin al branch “nombre_rama”.</td>
        </tr>
        <tr>
            <td>git remote prune origin:</td>
            <td>Actualiza tu repositorio remoto en caso que algún otro desarrollador haya eliminado alguna rama remota.</td>
        </tr> 
        <tr>
            <td>git reset --hard HEAD:</td>
            <td>Elimina los cambios realizados que aún no se hayan hecho commit.</td>
        </tr> 
        <tr>
            <td>git revert &#60;hash_commit&#62;:</td>
            <td>Revierte el commit realizado, identificado por el “hash_commit”.</td>
        </tr> 
   </table>     


<h3>Buenas prácticas</h3>
Se deben utilizar 4 tipos de ramas: Master, Development, Features, y Hotfix.
<ol>
    <li><strong>Master:</strong>
            Es la rama principal. Contiene el repositorio que se encuentra publicado en producción, por lo que debe estar siempre estable.</li>
    <li><strong>Development:</strong>
            Es una rama sacada de master. Es la rama de integración, todas las nuevas funcionalidades se deben integrar en esta rama. Luego que se realice la integración y se corrijan los errores (en caso de haber alguno), es decir que la rama se encuentre estable, se puede hacer un merge de development sobre la rama master.</li>
    <li><strong>Features:</strong>
            Cada nueva funcionalidad se debe realizar en una rama nueva, específica para esa funcionalidad. Estas se deben sacar de development. Una vez que la funcionalidad esté desarrollada, se hace un merge de la rama sobre development, donde se integrará con las demás funcionalidades.</li>
    <li><strong>Hotfix:</strong>
            Son bugs que surgen en producción, por lo que se deben arreglar y publicar de forma urgente. Es por ello, que son ramas sacadas de master. Una vez corregido el error, se debe hacer un merge de la rama sobre master. Al final, para que no quede desactualizada, se debe realizar el merge de master sobre development.</li>
</ol>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<p>Javier Álvarez Rial</p>

</body>
</html>